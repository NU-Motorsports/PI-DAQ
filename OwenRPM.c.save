/*
    UL call demonstrated:        	  ulCIn()

    Purpose:                          Reads a counter input channel

    Demonstration:                    Displays the event counter input data
                                      on a user-specified channel

    Steps:
    1. Call ulGetDaqDeviceInventory() to get the list of available DAQ devices
    2. Call ulCreateDaqDevice() to to get a handle for the first DAQ device
    3. Verify the DAQ device has a counter input subsystem
    4. Call ulConnectDaqDevice() to establish a UL connection to the DAQ device
    5. Call ulCClear() to clear the counter (set it to 0)
    6. Call ulCIn() to read a value from a counter channel
    7. Display the data for the specified counter
    8. Call ulDisconnectDaqDevice() and ulReleaseDaqDevice() before exiting the process.
*/

#include <stdio.h>
#include <stdlib.h>
#include "uldaq.h"
#include "utility.h"
#include <time.h>

#define MAX_DEV_COUNT  100

int main(void)
{

	time_t t = time(NULL);
	struct tm tm = *localtime(&t);
	printf("file created at: %d-%02d-%02d %02d:%02d:%02d\n", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
       
	char *filename;

	// sprintf needs a buffer
	
	//sprintf(filename, "test");
	//sprintf(filename, "%d-%02d-%02d___%02d-%02d-%02d.txt", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);

	//FILE *output = fopen(filename, "w"); // create a file for output // write only

	//fprintf("");

	// time, previousTime, Counter1, Counter2, ratio

	int descriptorIndex = 0;
	DaqDeviceDescriptor devDescriptors[MAX_DEV_COUNT];
	DaqDeviceInterface interfaceType = ANY_IFC;
	DaqDeviceHandle daqDeviceHandle = 0;
	unsigned int numDevs = MAX_DEV_COUNT;

	int ctrPrimary = 0;
	int ctrSecondary = 1;
	int hasCTR = 0;

	unsigned long long countPrimary = 0;
	unsigned long long countSecondary = 0;

	unsigned long long previousTime = 0;
	int measureTime = 10; //How long to wait between resetting the counters

	float ratio = 0;
	float primaryRPM = 0;
	float secondaryRPM = 0;

	UlError err = ERR_NO_ERROR;

	int i = 0;
	int __attribute__((unused)) ret;
	char c;

	// Get descriptors for all of the available DAQ devices
	err = ulGetDaqDeviceInventory(interfaceType, devDescriptors, &numDevs);

	if (err != ERR_NO_ERROR)
		goto end;

	// verify at least one DAQ device is detected
	if (numDevs == 0)
	{
		printf("No DAQ device is detected\n");
		goto end;
	}

	printf("Found %d DAQ device(s)\n", numDevs);
	for (i = 0; i < (int) numDevs; i++)
		printf("  [%d] %s: (%s)\n", i, devDescriptors[i].productName, devDescriptors[i].uniqueId);

	if(numDevs > 1)
		descriptorIndex = selectDAQDevice(numDevs);

	// get a handle to the DAQ device associated with the first descriptor
	daqDeviceHandle = ulCreateDaqDevice(devDescriptors[descriptorIndex]);

	if (daqDeviceHandle == 0)
	{
		printf ("\nUnable to create a handle to the specified DAQ device\n");
		goto end;
	}

	// verify the specified DAQ device supports counter input
	err = getDevInfoHasCtr(daqDeviceHandle, &hasCTR);
	if (!hasCTR)
	{
		printf("\nThe specified DAQ device does not support counter input\n");
		goto end;
	}

	printf("\nConnecting to device %s - please wait ...\n", devDescriptors[descriptorIndex].devString);

	// establish a connection to the DAQ device
	err = ulConnectDaqDevice(daqDeviceHandle);

	if (err != ERR_NO_ERROR)
		goto end;


	printf("\n%s ready\n", devDescriptors[descriptorIndex].devString);
	printf("    Function demonstrated: ulCIn()\n");
	printf("    Counters: %d,%d\n", ctrPrimary,ctrSecondary);
	printf("\nHit ENTER to continue\n");

	ret = scanf("%c", &c);

	ret = system("clear");

	// clear the counter
	err = ulCClear(daqDeviceHandle, ctrPrimary);
	err = ulCClear(daqDeviceHandle, ctrSecondary);

	if (err != ERR_NO_ERROR)
		goto end;

	while(err == ERR_NO_ERROR && !enter_press())
	{
		// reset the cursor to the top of the display and
		// show the termination message
		resetCursor();
	//	printf("Hit 'Enter' to terminate the process\n\n");
	//	printf("Active DAQ device: %s (%s)\n\n", devDescriptors[descriptorIndex].productName, devDescriptors[descriptorIndex].uniqueId);

		err = ulCIn(daqDeviceHandle, ctrPrimary, &countPrimary);
		err = ulCIn(daqDeviceHandle, ctrSecondary, &countSecondary);

		// display data for the counter channel
		if(err == ERR_NO_ERROR)
		{
			printf("Counter(%d,%d) Data: %lld,%lld\n", ctrPrimary, ctrSecondary, countPrimary, countSecondary);
			ratio=countPrimary/(float)countSecondary;
			printf("Ratio: %f\n", ratio);
			printf("Primary RPM: %f\n", primaryRPM);
			printf("Secondary RPM: %f\n", secondaryRPM);

			printf("%d,%d,%d,%d,%f,%f",time(0),previousTim,countPrimary,countSecondary,primaryRPM,secondaryRPM);
		}

		// check if the current time is at least 10s later than the last time data was cleared
		// clear the couters and record the current time
		// currently this is done with time(), but this only has second resolustion, might want to switch to something more precise later
		// -Owen
		if(time(0) >= previousTime + measureTime){
			primaryRPM = countPrimary/(time(0)-previousTime)*60;
			secondaryRPM = countSecondary/(time(0)-previousTime)*60;
			previousTime = time(0);
			ulCClear(daqDeviceHandle, ctrPrimary);
			ulCClear(daqDeviceHandle, ctrSecondary);
			printf("\e[1;H\e[2J"); //some way to clear the console that I found online -Owen
		}

		usleep(100000);
	}

	// disconnect from the DAQ device
	ulDisconnectDaqDevice(daqDeviceHandle);

end:

	// release the handle to the DAQ device
	ulReleaseDaqDevice(daqDeviceHandle);

	if(err != ERR_NO_ERROR)
	{
		char errMsg[ERR_MSG_LEN];
		ulGetErrMsg(err, errMsg);
		printf("Error Code: %d \n", err);
		printf("Error Message: %s \n", errMsg);
	}

	return 0;
}

